Index: modules/metadata/src/org/apache/axis2/jaxws/i18n/resource.properties
===================================================================
--- modules/metadata/src/org/apache/axis2/jaxws/i18n/resource.properties	(revision 751793)
+++ modules/metadata/src/org/apache/axis2/jaxws/i18n/resource.properties	(working copy)
@@ -182,3 +182,5 @@
 onewayAsync=The async listener property was set.  A one way invocation cannot be performed using an async response channel.
 soapBindingUseEncoded=The SEI {0} contains method {1} with an unsupported SOAPBinding annotation value. SOAPBinding.Use field cannot be set to ENCODED.
 soapBindingStyle=The SEI {0} contains method {1} with annotation SOAPBinding.Style set to RPC.
+validateImplErr=Validation error: Implementation subclass does not implement method on specified interface.  Implementation class: {0}; missing method name: {1}; endpointInterface: {2}
+
Index: modules/metadata/src/org/apache/axis2/jaxws/description/impl/ServiceDescriptionImpl.java
===================================================================
--- modules/metadata/src/org/apache/axis2/jaxws/description/impl/ServiceDescriptionImpl.java	(revision 751793)
+++ modules/metadata/src/org/apache/axis2/jaxws/description/impl/ServiceDescriptionImpl.java	(working copy)
@@ -987,62 +987,79 @@
         return validDefaultCtor;
     }
 
+
     private void validateImplementation(DescriptionBuilderComposite seic) {
         /*
-           *	Verify that an impl class implements all the methods of the SEI. We
-           *  have to verify this because an impl class is not required to actually use
-           *  the 'implements' clause. So, if it doesn't, the Java compiler won't
-           *	catch it. Don't need to worry about chaining because only one EndpointInterface
-           *  can be specified, and the SEI cannot specify an EndpointInterface, so the Java
-           *	compiler will take care of everything else.
-           */
+         *  Verify that an impl class implements all the methods of the SEI. We have to verify this 
+         *  because an impl class is not required to actually use the 'implements' clause. So, if 
+         *  it doesn't, the Java compiler won't catch it. Don't need to worry about chaining 
+         *  because only one EndpointInterface can be specified, and the SEI cannot specify an 
+         *  EndpointInterface, so the Java compiler will take care of everything else.
+         *  
+         *  Note, however, that we do need to take overloaded methods into a consideration.  The
+         *  same method name can be specified for multiple methods, but they can have different
+         *  parameters.  Note that methods which differ only in the return type or the exceptions
+         *  thrown are not overloaded (and therefore would cause a compile error).
+         */
 
-        HashMap<String, MethodDescriptionComposite> compositeHashMap = 
-            new HashMap<String, MethodDescriptionComposite>();
-        Iterator<MethodDescriptionComposite> compIterator =
-                composite.getMethodDescriptionsList().iterator();
-        while (compIterator.hasNext()) {
-            MethodDescriptionComposite mdc = compIterator.next();
-            compositeHashMap.put(mdc.getMethodName(), mdc);
-        }
+        List<MethodDescriptionComposite> implMethods = composite.getMethodDescriptionsList();
         // Add methods declared in the implementation's superclass
-        addSuperClassMethods(compositeHashMap, composite);
+        addSuperClassMethods(implMethods, composite);
 
-        HashMap<String, MethodDescriptionComposite> seiMethodHashMap = 
-            new HashMap<String, MethodDescriptionComposite>();
-        Iterator<MethodDescriptionComposite> seiMethodIterator =
-                seic.getMethodDescriptionsList().iterator();
-        while (seiMethodIterator.hasNext()) {
-            MethodDescriptionComposite mdc = seiMethodIterator.next();
-            seiMethodHashMap.put(mdc.getMethodName(), mdc);
-        }
+        List<MethodDescriptionComposite> seiMethods = seic.getMethodDescriptionsList();
         // Add any methods declared in superinterfaces of the SEI
-        addSuperClassMethods(seiMethodHashMap, seic);
+        addSuperClassMethods(seiMethods, seic);
 
         // Make sure all the methods in the SEI (including any inherited from superinterfaces) are
-        // implemented by the bean (including inherited methods on the bean).
-        Iterator<MethodDescriptionComposite> verifySEIIterator =
-                seiMethodHashMap.values().iterator();
+        // implemented by the bean (including inherited methods on the bean), taking into
+        // account overloaded methods.
+        Iterator<MethodDescriptionComposite> verifySEIIterator = seiMethods.iterator();
         while (verifySEIIterator.hasNext()) {
-            MethodDescriptionComposite mdc = verifySEIIterator.next();
-            // TODO: This does not take into consideration overloaded java methods!
-            MethodDescriptionComposite implMDC = compositeHashMap.get(mdc.getMethodName());
+            MethodDescriptionComposite seiMDC = verifySEIIterator.next();
             
-            if (implMDC == null) {
-                // TODO: RAS/NLS
-                throw ExceptionFactory.makeWebServiceException(
-                        "Validation error: Implementation subclass does not implement method on specified interface.  Implementation class: "
-                                + composite.getClassName() + "; missing method name: " +
-                                mdc.getMethodName() + "; endpointInterface: " +
-                                seic.getClassName());
-            } else {
-                //At least we found it, now make sure that signatures match up
+            // Make sure the implementation implements this SEI method.  Since we have to account
+            // for method overloading, we look for ALL methods with the same name in the 
+            // implementation, then from that collection of methods, we look for one that has the 
+            // same parameters.  If we find one with the same parameters, then we check the return
+            // and exceptions.  Note that in Java, overloaded methods are ones that have the same
+            // name but different parameters; a difference in the return type or thrown exceptions
+            // does not constitute overloading and is a compile error.
+            Iterator<MethodDescriptionComposite> implMDCIterator = implMethods.iterator();
+            boolean methodImplFound = false;
+            while (implMDCIterator.hasNext()) {
+                MethodDescriptionComposite implMDC = implMDCIterator.next();
                 
-                //Check for exception and signature matching
-                validateMethodExceptions(mdc, implMDC, seic.getClassName());
-                validateMethodReturnValue(mdc, implMDC, seic.getClassName());
-                validateMethodParameters(mdc, implMDC, seic.getClassName());
+                if (seiMDC.getMethodName().equals(implMDC.getMethodName())) {
+                    // The method names match, so now check the parameters
+                    try {
+                        validateMethodParameters(seiMDC, implMDC, seic.getClassName());
+                        methodImplFound = true;
+                    }
+                    catch (Exception ex) {
+                        // The parameters didn't match, so we'll check the next 
+                        // implemntation method on the next iteration of the inner loop.
+                    }
+                    
+                    // If the name and the parameters matched, then we've found the method
+                    // implementation, even if it was overloaded. Now check the return value and
+                    // thrown exceptions.  Note these will methods throw exceptions if validation fails.
+                    // If all the validation passes, we can break out of the inner loop since we 
+                    // found the implementation for this sei method.
+                    if (methodImplFound) {
+                        validateMethodExceptions(seiMDC, implMDC, seic.getClassName());
+                        validateMethodReturnValue(seiMDC, implMDC, seic.getClassName());
+                        break;
+                    }
+                }
             }
+            
+            if (!methodImplFound) {
+                // We didn't find the implementation for this SEI method, so throw a validation
+                // exception.
+                throw ExceptionFactory.makeWebServiceException(
+                		Messages.getMessage("validateImplErr",composite.getClassName(),
+                				seiMDC.getMethodName(),seic.getClassName()));
+            }
         }
     }
 
@@ -1200,29 +1217,27 @@
 
     }
 
-    /**
-     * Adds any methods declared in superclasses to the HashMap.  The hierachy starting with the DBC
+   /**
+     * Adds any methods declared in superclasses to the List.  The hierachy starting with the DBC
      * will be walked up recursively, adding methods from each parent DBC encountered.
      * <p/>
      * Note that this can be used for either classes or interfaces.
      *
-     * @param methodMap
-     * @param dbc
+     * @param methodList The current collection of methods, including overloaded ones
+     * @param dbc The composite to be checked for methods to be added to the collection
      */
-    private void addSuperClassMethods(HashMap methodMap, DescriptionBuilderComposite dbc) {
+    private void addSuperClassMethods(List<MethodDescriptionComposite> methodList, DescriptionBuilderComposite dbc) {
         DescriptionBuilderComposite superDBC = dbcMap.get(dbc.getSuperClassName());
         if (superDBC != null) {
-            Iterator<MethodDescriptionComposite> mIter =
-                    superDBC.getMethodDescriptionsList().iterator();
+            Iterator<MethodDescriptionComposite> mIter = superDBC.getMethodDescriptionsList().iterator();
             while (mIter.hasNext()) {
                 MethodDescriptionComposite mdc = mIter.next();
-                methodMap.put(mdc.getMethodName(), mdc);
+                methodList.add(mdc);
             }
-            addSuperClassMethods(methodMap, superDBC);
+            addSuperClassMethods(methodList, superDBC);
         }
     }
 
-
     /*
       * This method verifies that, if there are any WebMethod with exclude == false, then
       * make sure that we find all of those methods represented in the wsdl. However, if
Index: modules/metadata/src/org/apache/axis2/jaxws/description/impl/EndpointInterfaceDescriptionImpl.java
===================================================================
--- modules/metadata/src/org/apache/axis2/jaxws/description/impl/EndpointInterfaceDescriptionImpl.java	(revision 751793)
+++ modules/metadata/src/org/apache/axis2/jaxws/description/impl/EndpointInterfaceDescriptionImpl.java	(working copy)
@@ -46,6 +46,7 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
+import java.util.Map;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
@@ -629,9 +630,16 @@
                 new ArrayList<MethodDescriptionComposite>();
 
         if (dbc.isInterface()) {
+            if(log.isDebugEnabled()) {
+                log.debug("Removing overridden methods for interface: " + dbc.getClassName() + 
+                          " with super interface: " + dbc.getSuperClassName());
+            }
+            
+            // make sure we retrieve all the methods, then remove the overridden
+            // methods that exist in the base interface
+            retrieveList = retrieveSEIMethodsChain(dbc);
+            retrieveList = removeOverriddenMethods(retrieveList, dbc);
 
-            retrieveList.addAll(retrieveSEIMethodsChain(dbc));
-
         } else {
             //this is an implied SEI...rules are more complicated
 
@@ -723,6 +731,49 @@
     }
 
     /**
+     * This method drives the establishment of the hierarchy of interfaces for an SEI.
+     */
+    private Map<String, Integer> getInterfaceHierarchy(DescriptionBuilderComposite dbc) {
+        if(log.isDebugEnabled()) {
+            log.debug("Getting interface hierarchy for: " + dbc.getClassName());
+        }
+        Map<String, Integer> hierarchyMap = new HashMap<String, Integer>();
+        hierarchyMap.put(dbc.getClassName(), 0);
+        return getInterfaceHierarchy(dbc.getInterfacesList(), 
+                                     hierarchyMap, 
+                                     1);
+    }
+
+    /**
+     * Recursive method that builds the hierarchy of interfaces. This begins with an
+     * SEI and walks all of its super interfaces.
+     */
+    private Map<String, Integer> getInterfaceHierarchy(List<String> interfaces,
+                                                           Map<String, Integer> hierarchyMap,
+                                                           int level) {
+        HashMap<String, DescriptionBuilderComposite> dbcMap = getEndpointDescriptionImpl().
+            getServiceDescriptionImpl().getDBCMap();
+        
+        // walk through all of the interfaces
+        if(interfaces != null
+                &&
+                !interfaces.isEmpty()) {
+            for(String interfaze : interfaces) {
+                DescriptionBuilderComposite interDBC = dbcMap.get(interfaze);
+                if(interDBC != null) {
+                    if(log.isDebugEnabled()) {
+                        log.debug("Inserting super interface " + interDBC.getClassName() + 
+                                  " at level " + level);
+                    }
+                    hierarchyMap.put(interDBC.getClassName(), level);
+                    return getInterfaceHierarchy(interDBC.getInterfacesList(), hierarchyMap, level++);
+                }
+            }
+        }
+        return hierarchyMap;
+    }
+
+    /**
      * This method will loop through each method that was previously determined as being relevant to
      * the current composite. It will then drive the call to determine if this represents a method
      * that has been overridden. If it represents an overriding method declaration it will remove
@@ -735,7 +786,7 @@
     private ArrayList<MethodDescriptionComposite> removeOverriddenMethods(
             ArrayList<MethodDescriptionComposite>
                     methodList, DescriptionBuilderComposite dbc) {
-        HashMap<String, Integer> hierarchyMap = getClassHierarchy(dbc);
+        Map<String, Integer> hierarchyMap = dbc.isInterface() ? getInterfaceHierarchy(dbc) : getClassHierarchy(dbc);
         ArrayList<MethodDescriptionComposite> returnMethods =
                 new ArrayList<MethodDescriptionComposite>();
         for (int i = 0; i < methodList.size(); i++) {
@@ -779,8 +830,7 @@
     private static MethodDescriptionComposite getBaseMethod(MethodDescriptionComposite mdc,
                                                             int index,
                                                             ArrayList<MethodDescriptionComposite> methodList,
-                                                            HashMap<String, Integer>
-                                                                    hierarchyMap) {
+                                                            Map<String, Integer> hierarchyMap) {
         int baseLevel = hierarchyMap.get(mdc.getDeclaringClass());
         if (log.isDebugEnabled()) {
             log.debug("Base method: " + mdc.getMethodName() + " initial level: " + baseLevel);
Index: modules/metadata/pom.xml
===================================================================
--- modules/metadata/pom.xml	(revision 751793)
+++ modules/metadata/pom.xml	(working copy)
@@ -85,7 +85,7 @@
 			<resource>
 				<directory>src</directory>
 				<excludes>
-					<exclude>*.java</exclude>
+					<exclude>**/*.java</exclude>
 				</excludes>
 			</resource>
 		</resources>
